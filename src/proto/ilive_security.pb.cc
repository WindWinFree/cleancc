// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ilive_security.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "ilive_security.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace ilive_security {

namespace {

const ::google::protobuf::Descriptor* SecurityReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SecurityReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* SecurityRsp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SecurityRsp_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* SECURITY_ERROR_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* USER_TYPE_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_ilive_5fsecurity_2eproto() {
  protobuf_AddDesc_ilive_5fsecurity_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "ilive_security.proto");
  GOOGLE_CHECK(file != NULL);
  SecurityReq_descriptor_ = file->message_type(0);
  static const int SecurityReq_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecurityReq, check_word_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecurityReq, check_mask_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecurityReq, svr_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecurityReq, from_user_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecurityReq, to_user_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecurityReq, to_uin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecurityReq, from_nick_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecurityReq, client_ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecurityReq, use_white_list_),
  };
  SecurityReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SecurityReq_descriptor_,
      SecurityReq::default_instance_,
      SecurityReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecurityReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecurityReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SecurityReq));
  SecurityRsp_descriptor_ = file->message_type(1);
  static const int SecurityRsp_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecurityRsp, ret_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecurityRsp, sys_beat_level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecurityRsp, dirty_word_beat_),
  };
  SecurityRsp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SecurityRsp_descriptor_,
      SecurityRsp::default_instance_,
      SecurityRsp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecurityRsp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecurityRsp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SecurityRsp));
  SECURITY_ERROR_descriptor_ = file->enum_type(0);
  USER_TYPE_descriptor_ = file->enum_type(1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_ilive_5fsecurity_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SecurityReq_descriptor_, &SecurityReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SecurityRsp_descriptor_, &SecurityRsp::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_ilive_5fsecurity_2eproto() {
  delete SecurityReq::default_instance_;
  delete SecurityReq_reflection_;
  delete SecurityRsp::default_instance_;
  delete SecurityRsp_reflection_;
}

void protobuf_AddDesc_ilive_5fsecurity_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\024ilive_security.proto\022\016ilive_security\"\206"
    "\002\n\013SecurityReq\022\022\n\ncheck_word\030\001 \001(\014\022\022\n\nch"
    "eck_mask\030\002 \001(\r\022\020\n\010svr_type\030\003 \001(\r\0225\n\016from"
    "_user_type\030\004 \001(\0162\031.ilive_security.USER_T"
    "YPE:\002QQ\0223\n\014to_user_type\030\005 \001(\0162\031.ilive_se"
    "curity.USER_TYPE:\002QQ\022\016\n\006to_uin\030\006 \001(\004\022\026\n\016"
    "from_nick_name\030\007 \001(\014\022\021\n\tclient_ip\030\010 \001(\r\022"
    "\026\n\016use_white_list\030\t \001(\r\"P\n\013SecurityRsp\022\020"
    "\n\010ret_code\030\001 \001(\005\022\026\n\016sys_beat_level\030\002 \001(\r"
    "\022\027\n\017dirty_word_beat\030\003 \001(\r*\335\001\n\016SECURITY_E"
    "RROR\022\017\n\013SECURITY_OK\020\000\022\034\n\027SECURITY_PARAMS"
    "_INVALID\020\220N\022\032\n\025SECURITY_BACK_TIMEOUT\020\221N\022"
    "\031\n\024SECURITY_INNER_ERROR\020\222N\022\036\n\031SECURITY_W"
    "ORD_DIRTY_ERROR\020\223N\022!\n\034SECURITY_WORD_SECU"
    "RITY_ERROR\020\224N\022\"\n\035BOTH_SECURITY_AND_DIRTY"
    "_ERROR\020\225N*7\n\tUSER_TYPE\022\006\n\002QQ\020\000\022\n\n\006WECHAT"
    "\020\007\022\n\n\006ROOMID\020\004\022\n\n\006UNKNOW\020d2_\n\022ilive_secu"
    "rity_svr\022I\n\rSecurityCheck\022\033.ilive_securi"
    "ty.SecurityReq\032\033.ilive_security.Security"
    "Rsp", 763);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "ilive_security.proto", &protobuf_RegisterTypes);
  SecurityReq::default_instance_ = new SecurityReq();
  SecurityRsp::default_instance_ = new SecurityRsp();
  SecurityReq::default_instance_->InitAsDefaultInstance();
  SecurityRsp::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_ilive_5fsecurity_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_ilive_5fsecurity_2eproto {
  StaticDescriptorInitializer_ilive_5fsecurity_2eproto() {
    protobuf_AddDesc_ilive_5fsecurity_2eproto();
  }
} static_descriptor_initializer_ilive_5fsecurity_2eproto_;
const ::google::protobuf::EnumDescriptor* SECURITY_ERROR_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SECURITY_ERROR_descriptor_;
}
bool SECURITY_ERROR_IsValid(int value) {
  switch(value) {
    case 0:
    case 10000:
    case 10001:
    case 10002:
    case 10003:
    case 10004:
    case 10005:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* USER_TYPE_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return USER_TYPE_descriptor_;
}
bool USER_TYPE_IsValid(int value) {
  switch(value) {
    case 0:
    case 4:
    case 7:
    case 100:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int SecurityReq::kCheckWordFieldNumber;
const int SecurityReq::kCheckMaskFieldNumber;
const int SecurityReq::kSvrTypeFieldNumber;
const int SecurityReq::kFromUserTypeFieldNumber;
const int SecurityReq::kToUserTypeFieldNumber;
const int SecurityReq::kToUinFieldNumber;
const int SecurityReq::kFromNickNameFieldNumber;
const int SecurityReq::kClientIpFieldNumber;
const int SecurityReq::kUseWhiteListFieldNumber;
#endif  // !_MSC_VER

SecurityReq::SecurityReq()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SecurityReq::InitAsDefaultInstance() {
}

SecurityReq::SecurityReq(const SecurityReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SecurityReq::SharedCtor() {
  _cached_size_ = 0;
  check_word_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  check_mask_ = 0u;
  svr_type_ = 0u;
  from_user_type_ = 0;
  to_user_type_ = 0;
  to_uin_ = GOOGLE_ULONGLONG(0);
  from_nick_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  client_ip_ = 0u;
  use_white_list_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SecurityReq::~SecurityReq() {
  SharedDtor();
}

void SecurityReq::SharedDtor() {
  if (check_word_ != &::google::protobuf::internal::kEmptyString) {
    delete check_word_;
  }
  if (from_nick_name_ != &::google::protobuf::internal::kEmptyString) {
    delete from_nick_name_;
  }
  if (this != default_instance_) {
  }
}

void SecurityReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SecurityReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SecurityReq_descriptor_;
}

const SecurityReq& SecurityReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ilive_5fsecurity_2eproto();
  return *default_instance_;
}

SecurityReq* SecurityReq::default_instance_ = NULL;

SecurityReq* SecurityReq::New() const {
  return new SecurityReq;
}

void SecurityReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_check_word()) {
      if (check_word_ != &::google::protobuf::internal::kEmptyString) {
        check_word_->clear();
      }
    }
    check_mask_ = 0u;
    svr_type_ = 0u;
    from_user_type_ = 0;
    to_user_type_ = 0;
    to_uin_ = GOOGLE_ULONGLONG(0);
    if (has_from_nick_name()) {
      if (from_nick_name_ != &::google::protobuf::internal::kEmptyString) {
        from_nick_name_->clear();
      }
    }
    client_ip_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    use_white_list_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SecurityReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes check_word = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_check_word()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_check_mask;
        break;
      }

      // optional uint32 check_mask = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_check_mask:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &check_mask_)));
          set_has_check_mask();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_svr_type;
        break;
      }

      // optional uint32 svr_type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_svr_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &svr_type_)));
          set_has_svr_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_from_user_type;
        break;
      }

      // optional .ilive_security.USER_TYPE from_user_type = 4 [default = QQ];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_from_user_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ilive_security::USER_TYPE_IsValid(value)) {
            set_from_user_type(static_cast< ::ilive_security::USER_TYPE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_to_user_type;
        break;
      }

      // optional .ilive_security.USER_TYPE to_user_type = 5 [default = QQ];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_to_user_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ilive_security::USER_TYPE_IsValid(value)) {
            set_to_user_type(static_cast< ::ilive_security::USER_TYPE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_to_uin;
        break;
      }

      // optional uint64 to_uin = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_to_uin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &to_uin_)));
          set_has_to_uin();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_from_nick_name;
        break;
      }

      // optional bytes from_nick_name = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_from_nick_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_from_nick_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_client_ip;
        break;
      }

      // optional uint32 client_ip = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_client_ip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &client_ip_)));
          set_has_client_ip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_use_white_list;
        break;
      }

      // optional uint32 use_white_list = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_use_white_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &use_white_list_)));
          set_has_use_white_list();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SecurityReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes check_word = 1;
  if (has_check_word()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->check_word(), output);
  }

  // optional uint32 check_mask = 2;
  if (has_check_mask()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->check_mask(), output);
  }

  // optional uint32 svr_type = 3;
  if (has_svr_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->svr_type(), output);
  }

  // optional .ilive_security.USER_TYPE from_user_type = 4 [default = QQ];
  if (has_from_user_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->from_user_type(), output);
  }

  // optional .ilive_security.USER_TYPE to_user_type = 5 [default = QQ];
  if (has_to_user_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->to_user_type(), output);
  }

  // optional uint64 to_uin = 6;
  if (has_to_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->to_uin(), output);
  }

  // optional bytes from_nick_name = 7;
  if (has_from_nick_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      7, this->from_nick_name(), output);
  }

  // optional uint32 client_ip = 8;
  if (has_client_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->client_ip(), output);
  }

  // optional uint32 use_white_list = 9;
  if (has_use_white_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->use_white_list(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SecurityReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes check_word = 1;
  if (has_check_word()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->check_word(), target);
  }

  // optional uint32 check_mask = 2;
  if (has_check_mask()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->check_mask(), target);
  }

  // optional uint32 svr_type = 3;
  if (has_svr_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->svr_type(), target);
  }

  // optional .ilive_security.USER_TYPE from_user_type = 4 [default = QQ];
  if (has_from_user_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->from_user_type(), target);
  }

  // optional .ilive_security.USER_TYPE to_user_type = 5 [default = QQ];
  if (has_to_user_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->to_user_type(), target);
  }

  // optional uint64 to_uin = 6;
  if (has_to_uin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->to_uin(), target);
  }

  // optional bytes from_nick_name = 7;
  if (has_from_nick_name()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        7, this->from_nick_name(), target);
  }

  // optional uint32 client_ip = 8;
  if (has_client_ip()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->client_ip(), target);
  }

  // optional uint32 use_white_list = 9;
  if (has_use_white_list()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->use_white_list(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SecurityReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes check_word = 1;
    if (has_check_word()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->check_word());
    }

    // optional uint32 check_mask = 2;
    if (has_check_mask()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->check_mask());
    }

    // optional uint32 svr_type = 3;
    if (has_svr_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->svr_type());
    }

    // optional .ilive_security.USER_TYPE from_user_type = 4 [default = QQ];
    if (has_from_user_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->from_user_type());
    }

    // optional .ilive_security.USER_TYPE to_user_type = 5 [default = QQ];
    if (has_to_user_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->to_user_type());
    }

    // optional uint64 to_uin = 6;
    if (has_to_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->to_uin());
    }

    // optional bytes from_nick_name = 7;
    if (has_from_nick_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->from_nick_name());
    }

    // optional uint32 client_ip = 8;
    if (has_client_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->client_ip());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 use_white_list = 9;
    if (has_use_white_list()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->use_white_list());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SecurityReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SecurityReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SecurityReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SecurityReq::MergeFrom(const SecurityReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_check_word()) {
      set_check_word(from.check_word());
    }
    if (from.has_check_mask()) {
      set_check_mask(from.check_mask());
    }
    if (from.has_svr_type()) {
      set_svr_type(from.svr_type());
    }
    if (from.has_from_user_type()) {
      set_from_user_type(from.from_user_type());
    }
    if (from.has_to_user_type()) {
      set_to_user_type(from.to_user_type());
    }
    if (from.has_to_uin()) {
      set_to_uin(from.to_uin());
    }
    if (from.has_from_nick_name()) {
      set_from_nick_name(from.from_nick_name());
    }
    if (from.has_client_ip()) {
      set_client_ip(from.client_ip());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_use_white_list()) {
      set_use_white_list(from.use_white_list());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SecurityReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SecurityReq::CopyFrom(const SecurityReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SecurityReq::IsInitialized() const {

  return true;
}

void SecurityReq::Swap(SecurityReq* other) {
  if (other != this) {
    std::swap(check_word_, other->check_word_);
    std::swap(check_mask_, other->check_mask_);
    std::swap(svr_type_, other->svr_type_);
    std::swap(from_user_type_, other->from_user_type_);
    std::swap(to_user_type_, other->to_user_type_);
    std::swap(to_uin_, other->to_uin_);
    std::swap(from_nick_name_, other->from_nick_name_);
    std::swap(client_ip_, other->client_ip_);
    std::swap(use_white_list_, other->use_white_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SecurityReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SecurityReq_descriptor_;
  metadata.reflection = SecurityReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SecurityRsp::kRetCodeFieldNumber;
const int SecurityRsp::kSysBeatLevelFieldNumber;
const int SecurityRsp::kDirtyWordBeatFieldNumber;
#endif  // !_MSC_VER

SecurityRsp::SecurityRsp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SecurityRsp::InitAsDefaultInstance() {
}

SecurityRsp::SecurityRsp(const SecurityRsp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SecurityRsp::SharedCtor() {
  _cached_size_ = 0;
  ret_code_ = 0;
  sys_beat_level_ = 0u;
  dirty_word_beat_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SecurityRsp::~SecurityRsp() {
  SharedDtor();
}

void SecurityRsp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SecurityRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SecurityRsp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SecurityRsp_descriptor_;
}

const SecurityRsp& SecurityRsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ilive_5fsecurity_2eproto();
  return *default_instance_;
}

SecurityRsp* SecurityRsp::default_instance_ = NULL;

SecurityRsp* SecurityRsp::New() const {
  return new SecurityRsp;
}

void SecurityRsp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_code_ = 0;
    sys_beat_level_ = 0u;
    dirty_word_beat_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SecurityRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 ret_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_code_)));
          set_has_ret_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_sys_beat_level;
        break;
      }

      // optional uint32 sys_beat_level = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sys_beat_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sys_beat_level_)));
          set_has_sys_beat_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_dirty_word_beat;
        break;
      }

      // optional uint32 dirty_word_beat = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_dirty_word_beat:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dirty_word_beat_)));
          set_has_dirty_word_beat();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SecurityRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 ret_code = 1;
  if (has_ret_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ret_code(), output);
  }

  // optional uint32 sys_beat_level = 2;
  if (has_sys_beat_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->sys_beat_level(), output);
  }

  // optional uint32 dirty_word_beat = 3;
  if (has_dirty_word_beat()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->dirty_word_beat(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SecurityRsp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 ret_code = 1;
  if (has_ret_code()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ret_code(), target);
  }

  // optional uint32 sys_beat_level = 2;
  if (has_sys_beat_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->sys_beat_level(), target);
  }

  // optional uint32 dirty_word_beat = 3;
  if (has_dirty_word_beat()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->dirty_word_beat(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SecurityRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 ret_code = 1;
    if (has_ret_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ret_code());
    }

    // optional uint32 sys_beat_level = 2;
    if (has_sys_beat_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sys_beat_level());
    }

    // optional uint32 dirty_word_beat = 3;
    if (has_dirty_word_beat()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dirty_word_beat());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SecurityRsp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SecurityRsp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SecurityRsp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SecurityRsp::MergeFrom(const SecurityRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret_code()) {
      set_ret_code(from.ret_code());
    }
    if (from.has_sys_beat_level()) {
      set_sys_beat_level(from.sys_beat_level());
    }
    if (from.has_dirty_word_beat()) {
      set_dirty_word_beat(from.dirty_word_beat());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SecurityRsp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SecurityRsp::CopyFrom(const SecurityRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SecurityRsp::IsInitialized() const {

  return true;
}

void SecurityRsp::Swap(SecurityRsp* other) {
  if (other != this) {
    std::swap(ret_code_, other->ret_code_);
    std::swap(sys_beat_level_, other->sys_beat_level_);
    std::swap(dirty_word_beat_, other->dirty_word_beat_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SecurityRsp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SecurityRsp_descriptor_;
  metadata.reflection = SecurityRsp_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ilive_security

// @@protoc_insertion_point(global_scope)
