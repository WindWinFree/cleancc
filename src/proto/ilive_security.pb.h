// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ilive_security.proto

#ifndef PROTOBUF_ilive_5fsecurity_2eproto__INCLUDED
#define PROTOBUF_ilive_5fsecurity_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ilive_security {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ilive_5fsecurity_2eproto();
void protobuf_AssignDesc_ilive_5fsecurity_2eproto();
void protobuf_ShutdownFile_ilive_5fsecurity_2eproto();

class SecurityReq;
class SecurityRsp;

enum SECURITY_ERROR {
  SECURITY_OK = 0,
  SECURITY_PARAMS_INVALID = 10000,
  SECURITY_BACK_TIMEOUT = 10001,
  SECURITY_INNER_ERROR = 10002,
  SECURITY_WORD_DIRTY_ERROR = 10003,
  SECURITY_WORD_SECURITY_ERROR = 10004,
  BOTH_SECURITY_AND_DIRTY_ERROR = 10005
};
bool SECURITY_ERROR_IsValid(int value);
const SECURITY_ERROR SECURITY_ERROR_MIN = SECURITY_OK;
const SECURITY_ERROR SECURITY_ERROR_MAX = BOTH_SECURITY_AND_DIRTY_ERROR;
const int SECURITY_ERROR_ARRAYSIZE = SECURITY_ERROR_MAX + 1;

const ::google::protobuf::EnumDescriptor* SECURITY_ERROR_descriptor();
inline const ::std::string& SECURITY_ERROR_Name(SECURITY_ERROR value) {
  return ::google::protobuf::internal::NameOfEnum(
    SECURITY_ERROR_descriptor(), value);
}
inline bool SECURITY_ERROR_Parse(
    const ::std::string& name, SECURITY_ERROR* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SECURITY_ERROR>(
    SECURITY_ERROR_descriptor(), name, value);
}
enum USER_TYPE {
  QQ = 0,
  WECHAT = 7,
  ROOMID = 4,
  UNKNOW = 100
};
bool USER_TYPE_IsValid(int value);
const USER_TYPE USER_TYPE_MIN = QQ;
const USER_TYPE USER_TYPE_MAX = UNKNOW;
const int USER_TYPE_ARRAYSIZE = USER_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* USER_TYPE_descriptor();
inline const ::std::string& USER_TYPE_Name(USER_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    USER_TYPE_descriptor(), value);
}
inline bool USER_TYPE_Parse(
    const ::std::string& name, USER_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<USER_TYPE>(
    USER_TYPE_descriptor(), name, value);
}
// ===================================================================

class SecurityReq : public ::google::protobuf::Message {
 public:
  SecurityReq();
  virtual ~SecurityReq();

  SecurityReq(const SecurityReq& from);

  inline SecurityReq& operator=(const SecurityReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecurityReq& default_instance();

  void Swap(SecurityReq* other);

  // implements Message ----------------------------------------------

  SecurityReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecurityReq& from);
  void MergeFrom(const SecurityReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes check_word = 1;
  inline bool has_check_word() const;
  inline void clear_check_word();
  static const int kCheckWordFieldNumber = 1;
  inline const ::std::string& check_word() const;
  inline void set_check_word(const ::std::string& value);
  inline void set_check_word(const char* value);
  inline void set_check_word(const void* value, size_t size);
  inline ::std::string* mutable_check_word();
  inline ::std::string* release_check_word();
  inline void set_allocated_check_word(::std::string* check_word);

  // optional uint32 check_mask = 2;
  inline bool has_check_mask() const;
  inline void clear_check_mask();
  static const int kCheckMaskFieldNumber = 2;
  inline ::google::protobuf::uint32 check_mask() const;
  inline void set_check_mask(::google::protobuf::uint32 value);

  // optional uint32 svr_type = 3;
  inline bool has_svr_type() const;
  inline void clear_svr_type();
  static const int kSvrTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 svr_type() const;
  inline void set_svr_type(::google::protobuf::uint32 value);

  // optional .ilive_security.USER_TYPE from_user_type = 4 [default = QQ];
  inline bool has_from_user_type() const;
  inline void clear_from_user_type();
  static const int kFromUserTypeFieldNumber = 4;
  inline ::ilive_security::USER_TYPE from_user_type() const;
  inline void set_from_user_type(::ilive_security::USER_TYPE value);

  // optional .ilive_security.USER_TYPE to_user_type = 5 [default = QQ];
  inline bool has_to_user_type() const;
  inline void clear_to_user_type();
  static const int kToUserTypeFieldNumber = 5;
  inline ::ilive_security::USER_TYPE to_user_type() const;
  inline void set_to_user_type(::ilive_security::USER_TYPE value);

  // optional uint64 to_uin = 6;
  inline bool has_to_uin() const;
  inline void clear_to_uin();
  static const int kToUinFieldNumber = 6;
  inline ::google::protobuf::uint64 to_uin() const;
  inline void set_to_uin(::google::protobuf::uint64 value);

  // optional bytes from_nick_name = 7;
  inline bool has_from_nick_name() const;
  inline void clear_from_nick_name();
  static const int kFromNickNameFieldNumber = 7;
  inline const ::std::string& from_nick_name() const;
  inline void set_from_nick_name(const ::std::string& value);
  inline void set_from_nick_name(const char* value);
  inline void set_from_nick_name(const void* value, size_t size);
  inline ::std::string* mutable_from_nick_name();
  inline ::std::string* release_from_nick_name();
  inline void set_allocated_from_nick_name(::std::string* from_nick_name);

  // optional uint32 client_ip = 8;
  inline bool has_client_ip() const;
  inline void clear_client_ip();
  static const int kClientIpFieldNumber = 8;
  inline ::google::protobuf::uint32 client_ip() const;
  inline void set_client_ip(::google::protobuf::uint32 value);

  // optional uint32 use_white_list = 9;
  inline bool has_use_white_list() const;
  inline void clear_use_white_list();
  static const int kUseWhiteListFieldNumber = 9;
  inline ::google::protobuf::uint32 use_white_list() const;
  inline void set_use_white_list(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ilive_security.SecurityReq)
 private:
  inline void set_has_check_word();
  inline void clear_has_check_word();
  inline void set_has_check_mask();
  inline void clear_has_check_mask();
  inline void set_has_svr_type();
  inline void clear_has_svr_type();
  inline void set_has_from_user_type();
  inline void clear_has_from_user_type();
  inline void set_has_to_user_type();
  inline void clear_has_to_user_type();
  inline void set_has_to_uin();
  inline void clear_has_to_uin();
  inline void set_has_from_nick_name();
  inline void clear_has_from_nick_name();
  inline void set_has_client_ip();
  inline void clear_has_client_ip();
  inline void set_has_use_white_list();
  inline void clear_has_use_white_list();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* check_word_;
  ::google::protobuf::uint32 check_mask_;
  ::google::protobuf::uint32 svr_type_;
  int from_user_type_;
  int to_user_type_;
  ::google::protobuf::uint64 to_uin_;
  ::std::string* from_nick_name_;
  ::google::protobuf::uint32 client_ip_;
  ::google::protobuf::uint32 use_white_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_ilive_5fsecurity_2eproto();
  friend void protobuf_AssignDesc_ilive_5fsecurity_2eproto();
  friend void protobuf_ShutdownFile_ilive_5fsecurity_2eproto();

  void InitAsDefaultInstance();
  static SecurityReq* default_instance_;
};
// -------------------------------------------------------------------

class SecurityRsp : public ::google::protobuf::Message {
 public:
  SecurityRsp();
  virtual ~SecurityRsp();

  SecurityRsp(const SecurityRsp& from);

  inline SecurityRsp& operator=(const SecurityRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecurityRsp& default_instance();

  void Swap(SecurityRsp* other);

  // implements Message ----------------------------------------------

  SecurityRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecurityRsp& from);
  void MergeFrom(const SecurityRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ret_code = 1;
  inline bool has_ret_code() const;
  inline void clear_ret_code();
  static const int kRetCodeFieldNumber = 1;
  inline ::google::protobuf::int32 ret_code() const;
  inline void set_ret_code(::google::protobuf::int32 value);

  // optional uint32 sys_beat_level = 2;
  inline bool has_sys_beat_level() const;
  inline void clear_sys_beat_level();
  static const int kSysBeatLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 sys_beat_level() const;
  inline void set_sys_beat_level(::google::protobuf::uint32 value);

  // optional uint32 dirty_word_beat = 3;
  inline bool has_dirty_word_beat() const;
  inline void clear_dirty_word_beat();
  static const int kDirtyWordBeatFieldNumber = 3;
  inline ::google::protobuf::uint32 dirty_word_beat() const;
  inline void set_dirty_word_beat(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ilive_security.SecurityRsp)
 private:
  inline void set_has_ret_code();
  inline void clear_has_ret_code();
  inline void set_has_sys_beat_level();
  inline void clear_has_sys_beat_level();
  inline void set_has_dirty_word_beat();
  inline void clear_has_dirty_word_beat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_code_;
  ::google::protobuf::uint32 sys_beat_level_;
  ::google::protobuf::uint32 dirty_word_beat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ilive_5fsecurity_2eproto();
  friend void protobuf_AssignDesc_ilive_5fsecurity_2eproto();
  friend void protobuf_ShutdownFile_ilive_5fsecurity_2eproto();

  void InitAsDefaultInstance();
  static SecurityRsp* default_instance_;
};
// ===================================================================


// ===================================================================

// SecurityReq

// optional bytes check_word = 1;
inline bool SecurityReq::has_check_word() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecurityReq::set_has_check_word() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecurityReq::clear_has_check_word() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecurityReq::clear_check_word() {
  if (check_word_ != &::google::protobuf::internal::kEmptyString) {
    check_word_->clear();
  }
  clear_has_check_word();
}
inline const ::std::string& SecurityReq::check_word() const {
  return *check_word_;
}
inline void SecurityReq::set_check_word(const ::std::string& value) {
  set_has_check_word();
  if (check_word_ == &::google::protobuf::internal::kEmptyString) {
    check_word_ = new ::std::string;
  }
  check_word_->assign(value);
}
inline void SecurityReq::set_check_word(const char* value) {
  set_has_check_word();
  if (check_word_ == &::google::protobuf::internal::kEmptyString) {
    check_word_ = new ::std::string;
  }
  check_word_->assign(value);
}
inline void SecurityReq::set_check_word(const void* value, size_t size) {
  set_has_check_word();
  if (check_word_ == &::google::protobuf::internal::kEmptyString) {
    check_word_ = new ::std::string;
  }
  check_word_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityReq::mutable_check_word() {
  set_has_check_word();
  if (check_word_ == &::google::protobuf::internal::kEmptyString) {
    check_word_ = new ::std::string;
  }
  return check_word_;
}
inline ::std::string* SecurityReq::release_check_word() {
  clear_has_check_word();
  if (check_word_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = check_word_;
    check_word_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityReq::set_allocated_check_word(::std::string* check_word) {
  if (check_word_ != &::google::protobuf::internal::kEmptyString) {
    delete check_word_;
  }
  if (check_word) {
    set_has_check_word();
    check_word_ = check_word;
  } else {
    clear_has_check_word();
    check_word_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 check_mask = 2;
inline bool SecurityReq::has_check_mask() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SecurityReq::set_has_check_mask() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SecurityReq::clear_has_check_mask() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SecurityReq::clear_check_mask() {
  check_mask_ = 0u;
  clear_has_check_mask();
}
inline ::google::protobuf::uint32 SecurityReq::check_mask() const {
  return check_mask_;
}
inline void SecurityReq::set_check_mask(::google::protobuf::uint32 value) {
  set_has_check_mask();
  check_mask_ = value;
}

// optional uint32 svr_type = 3;
inline bool SecurityReq::has_svr_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SecurityReq::set_has_svr_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SecurityReq::clear_has_svr_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SecurityReq::clear_svr_type() {
  svr_type_ = 0u;
  clear_has_svr_type();
}
inline ::google::protobuf::uint32 SecurityReq::svr_type() const {
  return svr_type_;
}
inline void SecurityReq::set_svr_type(::google::protobuf::uint32 value) {
  set_has_svr_type();
  svr_type_ = value;
}

// optional .ilive_security.USER_TYPE from_user_type = 4 [default = QQ];
inline bool SecurityReq::has_from_user_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SecurityReq::set_has_from_user_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SecurityReq::clear_has_from_user_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SecurityReq::clear_from_user_type() {
  from_user_type_ = 0;
  clear_has_from_user_type();
}
inline ::ilive_security::USER_TYPE SecurityReq::from_user_type() const {
  return static_cast< ::ilive_security::USER_TYPE >(from_user_type_);
}
inline void SecurityReq::set_from_user_type(::ilive_security::USER_TYPE value) {
  assert(::ilive_security::USER_TYPE_IsValid(value));
  set_has_from_user_type();
  from_user_type_ = value;
}

// optional .ilive_security.USER_TYPE to_user_type = 5 [default = QQ];
inline bool SecurityReq::has_to_user_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SecurityReq::set_has_to_user_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SecurityReq::clear_has_to_user_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SecurityReq::clear_to_user_type() {
  to_user_type_ = 0;
  clear_has_to_user_type();
}
inline ::ilive_security::USER_TYPE SecurityReq::to_user_type() const {
  return static_cast< ::ilive_security::USER_TYPE >(to_user_type_);
}
inline void SecurityReq::set_to_user_type(::ilive_security::USER_TYPE value) {
  assert(::ilive_security::USER_TYPE_IsValid(value));
  set_has_to_user_type();
  to_user_type_ = value;
}

// optional uint64 to_uin = 6;
inline bool SecurityReq::has_to_uin() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SecurityReq::set_has_to_uin() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SecurityReq::clear_has_to_uin() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SecurityReq::clear_to_uin() {
  to_uin_ = GOOGLE_ULONGLONG(0);
  clear_has_to_uin();
}
inline ::google::protobuf::uint64 SecurityReq::to_uin() const {
  return to_uin_;
}
inline void SecurityReq::set_to_uin(::google::protobuf::uint64 value) {
  set_has_to_uin();
  to_uin_ = value;
}

// optional bytes from_nick_name = 7;
inline bool SecurityReq::has_from_nick_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SecurityReq::set_has_from_nick_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SecurityReq::clear_has_from_nick_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SecurityReq::clear_from_nick_name() {
  if (from_nick_name_ != &::google::protobuf::internal::kEmptyString) {
    from_nick_name_->clear();
  }
  clear_has_from_nick_name();
}
inline const ::std::string& SecurityReq::from_nick_name() const {
  return *from_nick_name_;
}
inline void SecurityReq::set_from_nick_name(const ::std::string& value) {
  set_has_from_nick_name();
  if (from_nick_name_ == &::google::protobuf::internal::kEmptyString) {
    from_nick_name_ = new ::std::string;
  }
  from_nick_name_->assign(value);
}
inline void SecurityReq::set_from_nick_name(const char* value) {
  set_has_from_nick_name();
  if (from_nick_name_ == &::google::protobuf::internal::kEmptyString) {
    from_nick_name_ = new ::std::string;
  }
  from_nick_name_->assign(value);
}
inline void SecurityReq::set_from_nick_name(const void* value, size_t size) {
  set_has_from_nick_name();
  if (from_nick_name_ == &::google::protobuf::internal::kEmptyString) {
    from_nick_name_ = new ::std::string;
  }
  from_nick_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityReq::mutable_from_nick_name() {
  set_has_from_nick_name();
  if (from_nick_name_ == &::google::protobuf::internal::kEmptyString) {
    from_nick_name_ = new ::std::string;
  }
  return from_nick_name_;
}
inline ::std::string* SecurityReq::release_from_nick_name() {
  clear_has_from_nick_name();
  if (from_nick_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_nick_name_;
    from_nick_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityReq::set_allocated_from_nick_name(::std::string* from_nick_name) {
  if (from_nick_name_ != &::google::protobuf::internal::kEmptyString) {
    delete from_nick_name_;
  }
  if (from_nick_name) {
    set_has_from_nick_name();
    from_nick_name_ = from_nick_name;
  } else {
    clear_has_from_nick_name();
    from_nick_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 client_ip = 8;
inline bool SecurityReq::has_client_ip() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SecurityReq::set_has_client_ip() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SecurityReq::clear_has_client_ip() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SecurityReq::clear_client_ip() {
  client_ip_ = 0u;
  clear_has_client_ip();
}
inline ::google::protobuf::uint32 SecurityReq::client_ip() const {
  return client_ip_;
}
inline void SecurityReq::set_client_ip(::google::protobuf::uint32 value) {
  set_has_client_ip();
  client_ip_ = value;
}

// optional uint32 use_white_list = 9;
inline bool SecurityReq::has_use_white_list() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SecurityReq::set_has_use_white_list() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SecurityReq::clear_has_use_white_list() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SecurityReq::clear_use_white_list() {
  use_white_list_ = 0u;
  clear_has_use_white_list();
}
inline ::google::protobuf::uint32 SecurityReq::use_white_list() const {
  return use_white_list_;
}
inline void SecurityReq::set_use_white_list(::google::protobuf::uint32 value) {
  set_has_use_white_list();
  use_white_list_ = value;
}

// -------------------------------------------------------------------

// SecurityRsp

// optional int32 ret_code = 1;
inline bool SecurityRsp::has_ret_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecurityRsp::set_has_ret_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecurityRsp::clear_has_ret_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecurityRsp::clear_ret_code() {
  ret_code_ = 0;
  clear_has_ret_code();
}
inline ::google::protobuf::int32 SecurityRsp::ret_code() const {
  return ret_code_;
}
inline void SecurityRsp::set_ret_code(::google::protobuf::int32 value) {
  set_has_ret_code();
  ret_code_ = value;
}

// optional uint32 sys_beat_level = 2;
inline bool SecurityRsp::has_sys_beat_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SecurityRsp::set_has_sys_beat_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SecurityRsp::clear_has_sys_beat_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SecurityRsp::clear_sys_beat_level() {
  sys_beat_level_ = 0u;
  clear_has_sys_beat_level();
}
inline ::google::protobuf::uint32 SecurityRsp::sys_beat_level() const {
  return sys_beat_level_;
}
inline void SecurityRsp::set_sys_beat_level(::google::protobuf::uint32 value) {
  set_has_sys_beat_level();
  sys_beat_level_ = value;
}

// optional uint32 dirty_word_beat = 3;
inline bool SecurityRsp::has_dirty_word_beat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SecurityRsp::set_has_dirty_word_beat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SecurityRsp::clear_has_dirty_word_beat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SecurityRsp::clear_dirty_word_beat() {
  dirty_word_beat_ = 0u;
  clear_has_dirty_word_beat();
}
inline ::google::protobuf::uint32 SecurityRsp::dirty_word_beat() const {
  return dirty_word_beat_;
}
inline void SecurityRsp::set_dirty_word_beat(::google::protobuf::uint32 value) {
  set_has_dirty_word_beat();
  dirty_word_beat_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ilive_security

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ilive_security::SECURITY_ERROR>() {
  return ::ilive_security::SECURITY_ERROR_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ilive_security::USER_TYPE>() {
  return ::ilive_security::USER_TYPE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ilive_5fsecurity_2eproto__INCLUDED
